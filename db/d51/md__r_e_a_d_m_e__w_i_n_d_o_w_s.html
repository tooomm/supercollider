<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SuperCollider: Welcome to Supercollider 3.8 for Windows!</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../sc_cube_48x48.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SuperCollider
   &#160;<span id="projectnumber">3.9.0</span>
   </div>
   <div id="projectbrief">Audio server, programming language, and IDE for sound and composition</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Welcome to Supercollider 3.8 for Windows! </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>IMPORTANT NOTE</b>:</p>
<p>This Readme has two sections: "Installing SuperCollider", and "Building
SuperCollider for Windows". The first section provides basic information to get going, and also introduces some common SuperCollider terminology. The second section is subdivided into two sections, "Quick Steps" and "Walkthroughs". Quick Steps contains the essentials for a successful build, the "Walkthroughs" are more tutorial-like and written for less experienced developers. They are not required reading to build the Windows version of SC. Furthermore the individual chapters in "Walkthroughs" are not expected to be read consecutively; they might appear quite repetitive if done so.</p>
<h2>Table of contents </h2>
<ul>
<li>Introduction</li>
<li><b>Installing SuperCollider</b><ul>
<li>System requirements</li>
<li>Using the SuperCollider IDE</li>
<li>Using SuperCollider in command line mode</li>
<li>Configuration- and support files</li>
<li>Extensions and Quarks</li>
</ul>
</li>
<li><b>Building SuperCollider for Windows</b><ul>
<li>Build Basics</li>
<li>Quick Steps<ul>
<li>Required software<ul>
<li>Getting packages with MSYS2</li>
<li>Getting the SuperCollider source code</li>
</ul>
</li>
<li>Arranging the components (non-MSYS2 builds only)</li>
<li>Configuring and executing a build<ul>
<li>MinGW (non-MSYS2)</li>
<li>Visual Studio 2013</li>
<li>MSYS2</li>
</ul>
</li>
<li>Additional build settings<ul>
<li><code>cmake</code> configuration options</li>
<li>Build options</li>
<li>Portaudio</li>
<li>HIDAPI with native MinGW builds</li>
</ul>
</li>
</ul>
</li>
<li>Diagnosing build problems<ul>
<li>Dirty build states</li>
<li>Wrong libraries found</li>
</ul>
</li>
<li>Walkthroughs<ul>
<li>The trial-error approach: building sc3-plugins and aggregating build settings to pass to <code>cmake</code></li>
<li>Avoiding the command line: from CMake-Gui to Visual Studio (environment and GUI-applications)</li>
<li>Using Qt Creator</li>
<li>More <code>cmake</code>: building supernova, qt-less, verbosity and more</li>
<li>Recalling environment- and build settings on the command line</li>
</ul>
</li>
</ul>
</li>
<li>Description of SC 3.8 release build</li>
<li>Known problems</li>
<li>Outro</li>
</ul>
<h1>Introduction </h1>
<p>This is the Windows version of James McCartney's SuperCollider synthesis engine (<code>scsynth</code>) and programming language (<code>sclang</code>), distributed together with a dedicated IDE (<code>scide</code>).</p>
<p>SuperCollider's central website is on Github: </p>
<pre class="fragment">http://supercollider.github.io/
</pre><p>Binaries of release-versions and pre-release snapshots are available as GitHub releases now: </p>
<pre class="fragment">https://github.com/supercollider/supercollider/releases
</pre><p>This page also provides snapshots of the source version used for the release. Note though, that this automated Github service misses out on the submodules. For actual development work you should always use SuperCollider's Github repo: </p>
<pre class="fragment">https://github.com/supercollider/supercollider
</pre><p>Older releases and snapshots of the source code used for them are available from Sourceforge: </p>
<pre class="fragment">http://sourceforge.net/projects/supercollider/files/?source=navbar
</pre><p>There is an online version of SuperCollider Help, the site SCDOC: </p>
<pre class="fragment">http://doc.sccode.org/Help.html
</pre><p>SC has a life in social media too. Visit a lively community at sccode.org: </p>
<pre class="fragment">http://sccode.org/
</pre><p>Listen to music composed with SuperCollider on SoundCloud: </p>
<pre class="fragment">https://soundcloud.com/groups/supercollider
</pre><p>There are several SuperCollider Facebook groups, some SuperCollider tweets, e.g. . In addition you are strongly encouraged to subscribe to the two SC mailing lists 'sc-users' and 'sc-dev'. You will get friendly and qualified replies there, as well as interest, and encouragement for your projects: </p>
<pre class="fragment">http://www.birmingham.ac.uk/facilities/ea-studios/research/supercollider/mailinglist.aspx
</pre><h1>Installing SuperCollider </h1>
<p>For SC itself just run the downloaded installer. If necessary select an alternative install path when prompted during installation. In order to uninstall, use the default procedure on Windows (Control panel -&gt; Uninstall a program) or run Uninstall.exe from within the SC installation folder. Note that files created in the 'user support directory' are not deleted (see below for details and an explanation).</p>
<p>IMPORTANT: in order to use the Quarks extension system you <em>need</em> to install Git <em>and</em> add it to the PATH. The Git installer will prompt you to the addition. For SC it is enough to add Git itself to the path, the additional unix tools (curl, find etc.) are not required.</p>
<p>Git for Windows is available from </p>
<pre class="fragment">http://git-scm.com/downloads
</pre><h2>System Requirements </h2>
<h3>Operating System</h3>
<ul>
<li>Windows 10</li>
<li>Windows 8</li>
<li>Windows 7</li>
<li>Windows Vista</li>
</ul>
<h3>Sound card</h3>
<p>Most sound cards running under Windows will work fine - the sound card should be one that is supported by <a href="http://www.portaudio.com/">PortAudio</a>. For professional use do some research and find a card that allows for low latency. If you have issues with latency, consult <a href="http://www.portaudio.com/docs/latency.html">http://www.portaudio.com/docs/latency.html</a> for advice on how to tune your operating system to achieve the best results. The portaudio build in SC supports various Windows audio APIs, among which you can chose. Usually you get best results and biggest control over latency by using the ASIO driver. If your soundcard does not provide an ASIO driver you should give *<a href="http://www.asio4all.com/" title="ASIO4ALL, generic ASIO driver">ASIO4ALL</a>* a try. See SC help for how to select the audio interface to be used by SC.</p>
<h2>Using the SuperCollider IDE </h2>
<p>To start up the IDE use the start menu link or run the scide.exe program found within the installation folder. On first start-up expect several firewall warnings to pop up. The SuperCollider components - the language interpreter 'sclang', the sound server 'scsynth' and the IDE 'scide' - communicate among each other over the network, so you will get a warning for each of the three executables. If you are new to SuperCollider, inspect the help system and look for the tutorials. You can open the help system using Ctrl+D. This keyboard shortcut is context sensitive - if your cursor is on a term from the supercollider language ('sclang'), the help system will likely open with the page explaining that term. Of course there is also the menu entry 'Help' -&gt; 'Show Help Browser'.</p>
<h2>Using SuperCollider in command line mode </h2>
<p><em>Note</em>: this is currently broken (Nov 2016, SC3.8). If you are using the 32-bit version, you can get output in emergency situations: either keep your finger on the key for about half a second or type each keystroke twice for it to register. You can also send text files to sclang by passing the filename as argument to <code>sclang</code>.</p>
<ol type="1">
<li>Open a Windows command line window (the cmd.exe program).</li>
<li>Navigate to the SuperCollider installation folder.</li>
<li>Start up the <code>sclang.exe</code> program to enter the SuperCollider command line.</li>
<li>You can now type SuperCollider code and evaluate it by pressing the Enter (Return) key. You can browse the previous commands using the up and down arrow keys.</li>
<li><p class="startli">Important keyboard shortcuts:</p>
<p class="startli"><code>Ctrl+t</code>: stop sound, equivalent to CmdPeriod.run <code>Ctrl+x</code>: recompile the class library <code>Ctrl+d</code>: quit the SuperCollider command line</p>
</li>
</ol>
<p>The interface uses the GNU library <a href="https://cnswww.cns.cwru.edu/php/chet/readline/rltop.html">Readline</a>.</p>
<p>If you want to use SC Help outside of the IDE, you must generate the help files first by running <code>SCDoc.renderAll</code>. Help files will by default be created in the 'user application support directory' (see below). Usually the html-files are aggregated with each help-file opened. With this command all files are generated at once.</p>
<h2>Configuration- and support files </h2>
<p>An important folder containing application related user data (for example extensions, quarks, Help files, plugins, configuration files, synthdefs) is located in the Windows 'local application data' folder. In SC-speak this folder is called the userAppSupportDir. This location is a bit tricky to find when not using SC-IDE because its grandparent <code>AppData</code> is hidden by default. You can see it in the environment variable LOCALAPPDATA. Type this on a command line: </p>
<pre class="fragment">$&gt; echo %LOCALAPPDATA%
</pre><p>You will likely see (the grandpa referred to earlier): </p>
<pre class="fragment">C:\Users\&lt;USERNAME&gt;\AppData
</pre><p>The userAppSupportDir is in the subfolder <code>Local\SuperCollider</code>: </p>
<pre class="fragment">C:\Users\&lt;USERNAME&gt;\AppData\Local\SuperCollider
</pre><p>This folder is user writable and <em>not</em> deleted by uninstall. Therefore your settings, quarks, plugins etc persist through SC-updates. This is usually good, but if you have binary "plugins" and update a minor version, e.g. 3.6 to 3.7, the plugins will not work any more, and cause errors during SC start-up. There are more files in the <code>userAppSupportDir</code> that can cause trouble after updates, so you want to be aware of the possibility. In the IDE it is very easy to access the folder. There is a menu entry -&gt; <code>Open user support directory</code>). You can also ask <code>sclang</code> where this folder is located. Type this in the SC-IDE: </p>
<pre class="fragment">Platform.userAppSupportDir
</pre><h2>Extensions and Quarks </h2>
<p>Extensions and Quarks are bundles of classes, and optionally plugins and help files that extend the functionality of core SC. The old school way of integrating them into SC is to move them to a folder called <code>Extensions</code> in the <code>userAppSupportDir</code> (soft linking is not supported any more).</p>
<p>The more flexible and recommended way since SC 3.7 does not restrict you to a single parent folder in a hidden system location. Any folder may be included among the folders scanned by SC at start-up ("compiled by the interpreter
sclang"). New folders are integrated into SC by adding them to the list of "include folders" listed in a file called <code>sclang_config.yaml</code> in the <code>userAppSupportDir</code>. This file can be edited manually, but you might find it easier to add or remove folders via the 'settings' dialog in the IDE, or:</p>
<p>The community driven <em>Quarks</em> system provides an automated way to add, remove and also distribute extensions. It "clones" extensions from repositories. By default it looks in a central repository called "Quarks", located on Github: </p>
<pre class="fragment">https://github.com/supercollider-quarks
</pre><p>Under the hood it speaks <code>sclang</code> and uses Git, so there is even some version control included. It also provides a management GUI that writes to the <code>sclang_config.yaml</code> mentioned above.</p>
<p><em>Note</em>: Each time <code>sclang_config.yaml</code> is modified (by editing, via a menu or by using the Quarks system) the interpreter has to be restarted ("rebooted") so that sclang can learn which files are available. This can be done via the menu entry 'Language -&gt; Restart Interpreter'. For an overview of the Quarks system see 'Help -&gt; Using Quarks'.</p>
<p>Enjoy SuperCollider!</p>
<h1>Building SuperCollider for Windows </h1>
<h2>Build Basics </h2>
<p>If you can't be bothered and have to get building immediately, then the quickest path through this material is:</p>
<ol type="1">
<li>Pick a build tool: VS 2013, native MinGW, or MSYS2</li>
<li>Download libraries as listed in "Required software"</li>
<li>If you're not using MSYS2, follow the instructions in "Arranging the components"</li>
<li>Jump to the section on your build tool under "Configuring and executing a
    build"</li>
</ol>
<p>Otherwise, read on.</p>
<p>SuperCollider uses the cross platform build system <a href="http://www.cmake.org/download/">CMake</a>, which works well for many OS and toolchain combinations. While CMake is command-line oriented, it can also be controlled from a GUI (<code>cmake-gui</code>) and is very well integrated into Qt Creator.</p>
<p>There are three main ways you can build SuperCollider on Windows:</p>
<ul>
<li>Visual Studio 2013</li>
<li>Native MinGW</li>
<li>MSYS2 + MinGW</li>
</ul>
<p>Of these, MSYS2 will be the most familiar for Unix developers.</p>
<p>Some approaches are limited in certain respects:</p>
<ul>
<li>Visual Studio cannot build libreadline or supernova (a multithreading version of scsynth)</li>
<li>Native MinGW can only build a 32-bit executable</li>
<li>Visual Studio and native MinGW are limited to Qt 5.5.1</li>
</ul>
<p>The Windows port of SC is in a stage of transition. Native MinGW is the oldest method; Visual Studio 2013 is newer; and MSYS2 support was only made available while developing SuperCollider 3.9. Keeping these options open will make it easier for those who already do Windows development to get started with SuperCollider, without having to be limited by toolchain or IDE.</p>
<h2>Quick Steps </h2>
<h3>Required software</h3>
<p>To build with Visual Studio or native MinGW, you will have to download and install these packages manually. When you are given the option, make sure to choose the 32-bit or 64-bit version of each library as appropriate. For MSYS2, see the instructions below.</p>
<ul>
<li>**<a href="http://git-scm.com/download/win" title="Git for Windows">Git</a>** for Windows</li>
<li>**<a href="http://www.cmake.org/download/">CMake</a>**: 3.5.2 with native minGW; otherwise, latest version</li>
<li>The SuperCollider source code</li>
<li>Build tools: one of<ul>
<li>MinGW as bundled with **<a href="https://download.qt.io/archive/qt/5.5/5.5.1/">Qt 5.5.1</a>** (distribution 'mingw492')</li>
<li>**<a href="https://msys2.github.io/">MSYS2+MinGW</a>**</li>
<li>**<a href="https://www.visualstudio.com/vs/older-downloads/" title="you need to create a free developer account to download Visual Studio 2013, community edition">Visual Studio 12 2013</a>**: note that you will need to join Visual Studio Team Services (for free) in order to download this older version</li>
</ul>
</li>
<li>Required Libraries<ul>
<li><p class="startli">**<a href="http://www.qt.io/download-open-source/#section-2" title="Qt official distribution, choose online installer">Qt</a>** &gt;= 5.5.1. The current version, 5.8, works with MSYS2. For Visual Studio and native MinGW, you must use 5.5.1 as the WebKit component of Qt, which SuperCollider's IDE requires, was dropped in 5.6.</p>
<p class="startli">If you're not using MSYS2, use the official archived download, and choose from the following packages:</p>
<ul>
<li>msvc2013_64, for a 64-bit Visual Studio build</li>
<li>msvc2013, for a 32-bit Visual Studio build</li>
<li>mingw492 (32-bit), for a MinGW build</li>
</ul>
</li>
<li>**<a href="http://www.mega-nerd.com/libsndfile/">libsndfile</a>** &gt;= 1.0.25</li>
<li>The **<a href="https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk" title="Windows 10 SDK including debugger used by Qt Creator">Windows SDK</a>** for your edition of Windows</li>
</ul>
</li>
<li>Recommended Libraries<ul>
<li>**<a href="http://www.fftw.org/install/windows.html">fftw</a>** &gt;= 3.3.4. See the instructions below on arranging the libraries if you are making a Visual Studio or native MinGW build.</li>
<li>**<a href="http://www.steinberg.net/en/company/developers.html" title="ASIO SDK v2.3">Asio SDK</a>** &gt;= 2.3, for Asio support in PortAudio</li>
</ul>
</li>
<li>Optional Libraries<ul>
<li>**<a href="http://gnuwin32.sourceforge.net/packages/readline.htm">readline</a>** = 5.0.1. More recent versions found in MinGW distributions do <em>not</em> currently work in <em>native</em> MinGW builds. In MSYS builds more recent (and 64-bit) versions cann be used, see however the restrictions mentioned in the introductory note of "Using SC on the
        command line". Readline cannot be used at all in Visual Studio builds.</li>
<li><b>DirectX SDK</b> <a href="http://www.microsoft.com/en-us/download/details.aspx?id=6812" title="MS DirectX 9 SDK (June 2010\) for VS build">v.9</a> for VS build. (Direct Sound support in Portaudio)</li>
<li>**<a href="http://nsis.sourceforge.net/Download" title="create installer">NSIS</a>**, if you want to create a binary SC installer (add the binary <code>makensis</code> to PATH)</li>
</ul>
</li>
<li>Convenience<ul>
<li>a Unix line-ending friendly text editor like **<a href="https://atom.io/" title="free unixy text editor with SuperCollider package">Atom</a>** or **<a href="http://notepad-plus-plus.org" title="free unixy text editor">Notepad++</a>**. There are SuperCollider packages available for Atom; we recommend using that.</li>
<li>**<a href="http://www.7-zip.org" title="unixy decompression tool">7-zip</a>** to extract .tar and .gz format archives</li>
</ul>
</li>
</ul>
<h4>Getting packages with MSYS2</h4>
<p>If this is your first time using MSYS2, here are some things to know. People who grew up with Windows hate MSYS2, people with a Unix background think it is God sent. Make your choice. As a build system it is as close as it can get to an Arch Linux clone running within Windows.</p>
<p>MSYS2 offers very up-to-date 32- and 64-bit versions of every package, and provides a full set of libraries built with the same toolchain, so compatibility considerations are a thing of the past. If you haven't downloaded it yet, <a href="https://msys2.github.io/">do that now</a> and consider reading over the wiki before continuing: </p>
<pre class="fragment">https://github.com/msys2/msys2/wiki
</pre><p>The prefix <code>mingw-w64-</code> distinguishes a package as being used outside the enviroment of MSYS2—in other words, things you'll use to build SuperCollider! <code>x86_64</code> bit identifies a package as being 64-bit, and <code>i686</code> means 32-bit.</p>
<p>MSYS2 uses a clone of the Arch Linux package manager, <code>pacman</code>. After opening the MinGW64 shell installed with MSYS2, run the following command repeatedly until MSYS2 is fully updated: </p>
<pre class="fragment">pacman -Syuu
</pre><p>Get some basic packages: </p>
<pre class="fragment">pacman -S base-devel git mingw-w64-x86_64-toolchain
</pre><p>Some other, completely optional tools (not used for building SuperCollider): </p>
<pre class="fragment">pacman -S subversion p7zip perl ruby python2 nano vim emacs
</pre><p>Now get the remaining packages needed for SuperCollider. If you want to be able to do both 32-bit and 64-bit builds, use <code>{x86_64,i686}</code> in place of <code>x86_64</code>: </p>
<pre class="fragment">pacman -S mingw-w64-x86_64-{qt5,clang,cmake,portaudio,libsndfile,fftw}
</pre><p>A free IDE with good Qt and Cmake integration is: </p>
<pre class="fragment">- `mingw_w64-x86_64-qt-creator` for Qt Creator.
</pre><p>If you plan to build supernova, you will also need: </p>
<pre class="fragment">- `mingw-w64-x86_64-dlfcn`
</pre><p>If you are not sure what a package is called you can search: </p>
<pre class="fragment">pacman -Ss libsndfile
</pre><h4>Getting the SuperCollider source code</h4>
<p><code>cd</code> to wherever you'd like to build SuperCollider, then: </p>
<pre class="fragment">git clone --recursive https://github.com/supercollider/supercollider.git
</pre><p>If you checkout different stages of the source code history, at some point switching to different stages of submodules might be required. In this case use: </p>
<pre class="fragment">git submodule update
</pre><p><code>git submodule sync</code> is useful if the address of a submodule has changed; Git will usually tell if a resynchronization/update is required.</p>
<p><em>Fine print</em>: the PortAudio library is not available as binary download. A slightly patched version of its source is provided as submodule. Portaudio can support up to five different backends: MME, DSound, WDM-KS, ASIO and WASAPI.</p>
<ul>
<li>For ASIO support the (gratis) ASIO-SDK from Steinberg has to be added to the source tree in any build environment.</li>
<li>For DSound support the <em>Visual Studio</em> build requires to install the DirectX SDK Version 9. (MinGW (and implicitly MSYS2) provide the required libraries)</li>
</ul>
<p>The MSYS2 SC-build uses the binary portaudio package provided by MSYS2. By default this only comes with MME and DSound support. If you want additional backends (ASIO and/or WDM-KS strongly recommended) you need to rebuild the portaudio package within the MSYS2 environment (very easy).</p>
<h3>Arranging the components (non-MSYS2 builds only)</h3>
<p><em>Note:</em> creating the folder structure <em>exactly as given here</em> will save you from likely frustration when CMake cannot find dependencies.</p>
<p>Create a new folder next to where you cloned SuperCollider. If you're making a 32-bit build, call it <code>x86</code>; use <code>x64</code> for 64-bit. Move the installed files of <code>libsndfile</code> and the libraries for <code>readline</code> and <code>fftw</code> so that they match the following folder structure <em>exactly</em>: </p>
<pre class="fragment">supercollider
x64 (or x86)
    libsndfile
        bin
        include
        lib
    readline
        bin
        include
        lib
    fftw
</pre><p>If you are making a Visual Studio build, you must create library files by <code>cd</code>ing to the fftw directory and executing the following command: </p>
<pre class="fragment">lib /def:libfftw3f-3.def
</pre><p>Note: the SC build only uses the single precision version of the fftw library (fftw3f).</p>
<p>For 64-bit, add <code>/machine:x64</code>: </p>
<pre class="fragment">lib /machine:x64 /def:libfftw3f-3.def
</pre><p><em>Note</em>: if you compile FFTW yourself, all files must end up in the root fftw directory.</p>
<p>In order to get support for ASIO drivers, follow this directory structure: </p>
<pre class="fragment">supercollider
    external_libraries
        portaudio_sc_org
        asiosdk
            asio
            common
            ...
        ...
</pre><p>For DSound support in Visual Studio, you have to download the DirectX SDK <a href="http://www.microsoft.com/en-us/download/details.aspx?id=6812" title="MS DirectX 9 SDK (June 2010\) for VS build">version 9</a> and install it.</p>
<p><em>Fine print</em>: If you install the DirectX SDK and try to build using MinGW, the PortAudio build will likely break. Try to avoid the DXSDK detection in that case; for example, by editing CMakeLists.txt in the PortAudio root folder. DSound support will nevertheless be built when using MinGW libraries. If you want to avoid adding in DS-support, set <code>PA_USE_DS</code> in the same file to <code>OFF</code>.</p>
<h3>Configuring and executing the build</h3>
<p>The sections below assume that you are comfortable with the command line. If not, see the walkthrough below, "Avoiding the command line".</p>
<p>Once everything has been arranged properly, <code>cmake</code> must be told: </p>
<pre class="fragment">- which "generator" to use
- the location of the compiler
- the location of Qt
- the location of SuperCollider's source code
</pre><p>If you're all set, jump to the section below specific to your build tool.</p>
<p><em>Note:</em> You should always use forward slashes for path statements when using CMake commands. When creating/modifying environment variables, or interacting otherwise directly with Windows command line functionality (<code>cd</code>, <code>rmdir</code>, ...), you should use the proper Windows syntax with backslashes as directory delimiters.</p>
<p><em>Note:</em> The SC source given as the last parameter of the <code>cmake</code> command. The pointer to the source directory is the only element of the cmake command that has to be repeated each time cmake is run to configure the build. The other options are stored in "CMakeCache.txt" in the build folder for subsequent runs.</p>
<h4>MinGW (non-MSYS2)</h4>
<p>The following steps build SuperCollider in a subdirectory of the SC source directory called 'build'. You may want to check the path where you installed Qt—if it's not <code>C:\Qt\</code>, then change these commands accordingly. You should <code>cd</code> into the SuperCollider source folder to begin. </p>
<pre class="fragment">SET PATH=C:\Qt\5.5\mingw492_32\bin;C:\Qt\Tools\mingw492_32\bin;%PATH%
SET CMAKE_PREFIX_PATH=C:\Qt\5.5\mingw492_32
mkdir build
cd build
cmake -G "MinGW Makefiles" ..
cmake --build .
</pre><p>This is the bare-bones, dead-simple way to build SuperCollider with MinGW!</p>
<p>A line-by-line explanation: </p>
<pre class="fragment">SET PATH=C:\Qt\5.5\mingw492_32\bin;C:\Qt\Tools\mingw492_32\bin;%PATH%
SET CMAKE_PREFIX_PATH=C:\Qt\5.5\mingw492_32
</pre><p>Tell <code>cmake</code> where to look for the Qt files and MinGW. </p>
<pre class="fragment">mkdir build
cd build
</pre><p>Create the build directory and move into it. </p>
<pre class="fragment">cmake -G "MinGW Makefiles" ..
</pre><p>Configure the makefiles to prepare for building. </p>
<pre class="fragment">cmake --build .
</pre><p>Mind the dot after <code>build</code>. It refers to the folder where the cmake build configuration files are located.</p>
<p>Build SuperCollider.</p>
<h4>Visual Studio 2013</h4>
<p>You may want to check the path where you installed Qt—if it's not <code>C:\Qt\</code>, then change these commands accordingly. You should <code>cd</code> into the SuperCollider source folder to begin. </p>
<pre class="fragment">SET PATH=C:\Qt\5.5\msvc2013_64\bin;C:\Qt\Tools\msvc2013_64\bin;%PATH%
SET CMAKE_PREFIX_PATH=C:\Qt\5.5\msvc2013_64
mkdir build
cd build
cmake -G "Visual Studio 12 2013 Win64" ..
</pre><p>For the final step, you can either build within the Visual Studio IDE: </p>
<pre class="fragment">start SuperCollider.sln
</pre><p>Or build using <code>cmake</code> as usual: </p>
<pre class="fragment">cmake --build .
</pre><p>The preceding MinGW section contains an explanation of this command sequence.</p>
<h4>MSYS2</h4>
<pre class="fragment">mkdir build
cd build
cmake -G "MSYS Makefiles" ..
cmake --build . -- -j4
</pre><p>The preceding MinGW section contains an explanation of this command sequence. <code>-- -j4</code> passes the argument -j4 (use 4 processor threads) to the makefile. Adjust the number to your processor ;)</p>
<h3>Additional build settings</h3>
<p>Listed here are common additional configurations you may want to use. For a more complete list, use <code>cmake --help</code> and/or see the section "More `cmake`:
building supernova, qt-less, verbosity and more" below.</p>
<h4><code>cmake</code> configuration options</h4>
<p>There are a number of additional options you can use in the penultimate build step: </p>
<pre class="fragment">cmake -G "Toolchain Name" [-D OPTION_NAME] ..
</pre><p>When using native MinGW or MSYS2 you can specify the build configuration with <code>CMAKE_BUILD_TYPE</code>. The default is <code>RelWithDebInfo</code> ("Release build, with debug
info"), but there are other possibilities: </p>
<pre class="fragment">cmake -D CMAKE_BUILD_TYPE=Debug ..
cmake -D CMAKE_BUILD_TYPE=Release ..
cmake -D CMAKE_BUILD_TYPE=RelMinSize ..
</pre><p>When using Visual Studio the build configuration can only be specified in the build step. Default here is <code>Debug</code>: </p>
<pre class="fragment">cmake --build . --config Release
</pre><p>If you want to build supernova, add <code>-D SUPERNOVA=ON</code> </p>
<pre class="fragment">cmake -D SUPERNOVA=ON ..
</pre><h4>Build options</h4>
<p>If you used the basic instructions above, you will end up with three target folders (four if supernova is built). You can run these executables to develop SuperCollider, but, as the Qt libraries are not copied to the target folders, you <em>must</em> keep Qt5 in your environment PATH when running sclang or sc-ide. The target folders are: </p>
<pre class="fragment">sc-ide:    build-folder\editors\scide\&lt;build configuration&gt;
sclang:    build-folder\lang\&lt;build configuration&gt;
scsynth:   build-folder\server\scsynth\&lt;build configuration&gt;
supernova: build-folder\server\supernova\&lt;build configuration&gt;
</pre><p>Other targets (like plugins and external libraries) do not provide executables and thus cannot be run. If you use a development IDE (Qt Creator), it should recognize the target executable automatically when you "Run" or "Debug" one of the targets containing an executable. The target to be run is set in the Projects/Run-pane accessible from the "Mode selector"-ribbon. You should also set the working directory there to allow sclang find the server (for more information on using QtC see the walkthrough below).</p>
<p>If you want to run SuperCollider independently of the build environment: </p>
<pre class="fragment">cmake --build . --target install
</pre><p>This "builds the target install", which means that the SC files proper are combined with all required external libraries to create a <em>portable</em> application folder.</p>
<p>If you want to create a binary installer, first build the target install, then make sure <code>makensis</code>, the command-line tool for NSIS, is in your PATH: </p>
<pre class="fragment">cmake --build . --target installer
</pre><p>The SuperCollider installer executable will be built in the directory path: </p>
<pre class="fragment">...\build\Install\SuperCollider.exe
</pre><p>The exact name will vary depending on what architecture and build configuration you specified.</p>
<p>Note that for just passing SC to a friend it is not really necessary to create an installer. You can copy the main SuperCollider folder created during install to another machine. The binary installer just packages this folder and adds a few installation details like registering the uninstaller in the system and removing some registry settings during uninstall. The userAppSupportDirectory will be created from scratch if SuperCollider doesn't find it during start-up. Whether you copy the SC install folder, or use the full installer, you will always loose the local customizations and additions stored in the userAppSupportDirectory. The new Quarks system provides means to make porting of extension/Quark groups easier.</p>
<h4>Portaudio</h4>
<p>Portaudio is provided as submodule of SC and is built automatically as part of the SC-build. In order to add ASIO- and/or DSound support, the respective SDKs have to be added to the build.</p>
<p>ASIO: download the SDK from <a href="http://www.steinberg.net/en/company/developers.html" title="ASIO SDK v2.3">Steinberg</a>, extract the zip and place the folder in a sibling folder of the portaudio folder in external_libraries. The folder name should not contain dots, start with <code>as</code>, and be the immediate parent of the library folders (asio, common, ...). You should end up with a folder tree like this: </p>
<pre class="fragment">sc-source
    external_libraries
        portaudio_sc_org
        asiosdk
            asio
            common
            driver
            host
</pre><p>DSound/DirectX: The VS-build requires DirectX. It should be installed as usual. <a href="http://www.microsoft.com/en-us/download/details.aspx?id=6812" title="MS DirectX 9 SDK (June 2010\) for VS build">version 9 (June 2010)</a>.</p>
<p>You can study the file <code>CMakeLists.txt</code> in the portaudio folder (external_libraries) to learn about the options that the build provides. With default settings, all APIs that <em>work out of the box</em> are enabled and only the library for static linking is built. In the VS-build all APIs are enabled, in the MinGW build WASAPI had to be omitted, and some features of full duplex mode in DSound had to be disabled. If you would like to tweak the PA- build you can single it out from the SC build like so: </p>
<pre class="fragment">cmake --build . --target portaudio
</pre><p>MSYS2 provides a portaudio package, but it only comes with MME and DSound support out of the box. If you want ASIO or WDM-KS, you need to build portaudio within the MSYS2 framework. At the time of this writing the WASAPI backend could not be built in MinGW-based environments. Use VS, if you need WASAPI.</p>
<h4>HIDAPI with native MinGW builds</h4>
<p>Currently, HIDAPI is disabled by default for native MinGW builds using MinGW/GCC versions below 5.3. It can be enabled by manually altering the source code:</p>
<p>In <code>/external-libraries/hidapi/hidapi_parser/hidapi_parser.c</code>, change the header includes as follows: </p>
<pre class="fragment">// #include &lt;hidsdi.h&gt;
#include "../windows/hidsdi.h"
</pre><p>In <code>SC-source/external-libraries/hidapi/windows/hid.c</code>: </p>
<pre class="fragment">// #include &lt;hidsdi.h&gt;
#include "./hidsdi.h"
</pre><p>Rerun the cmake configuration step and add the argument: </p>
<pre class="fragment">-D SC_HIDAPI=ON
</pre><p>SuperCollider will now build with HIDAPI.</p>
<h2>Troubleshooting build problems </h2>
<p>These are likely the most common causes of build problems:</p>
<ul>
<li>After run- or debug-sessions, sometimes scsynth or sclang "zombies" stay in memory. That will create file-access errors during build. End the process the in the task manager.</li>
<li>Make sure you are using the correct toolchain and libraries; double-check the instructions above in "Required Software", paying special attention to any version restrictions for your particular build toolchain.</li>
<li>Dynamic/runtime-library mismatch. This can happen if dependencies and core SC require different versions of the same runtime library. Reach out for libraries that do not depend on MinGW runtimes or make sure all components in the build can use the same runtimes.</li>
<li>Architecture mismatches. This does not only concern target system architecture (32- or 64-bit) but also the toolchain used to compile SC and Qt. They have to match as closely as possible. SC built with VS requires the msvc2013_64 package; the MinGW 4.8.2 build requires mingw492_32.</li>
<li>Dirty states in your build folder (usually resulting from changes in the build configuration). See below for how to fix this.</li>
<li>cmake finds and uses different libraries on your system than the ones intended for the build. See below for ways to identify these problems.</li>
</ul>
<p>When asking for build help, please mention the installed versions of the components you used to build SC!</p>
<h3>Dirty build states</h3>
<p>While you are developing SC code, it's generally safe to reuse your build folder; the build will complete <em>much</em> faster. If you change branches, build tools, cmake settings, or the versions of your dependencies, things are less safe, the build configuration might have gone out of sync with the files used in the build, without CMake being aware of it. There are a few ways to clean your build. In order of increasing severity:</p>
<ol type="1">
<li>Delete individual entries from CMakeCache.txt to make sure they are rewritten</li>
<li>Delete all stored configuration settings for that build: <code>del CMakeCache.txt</code></li>
<li>Remove the compiled object files from the build (forces recompile): <code>cmake --build . --target clean</code></li>
<li>Delete everything in the build folder, via File Explorer or <code>rmdir build /s /q</code></li>
</ol>
<p>Generally, clearing the CMakeCache.txt and rerunning <code>cmake</code> should be enough to fix many build problems. Switching git branches that only contain changes to code in SuperCollider proper should usually not require this kind of repair.</p>
<h3>Wrong libraries found</h3>
<p>While some precautions have been taken to prevent wrong finds, it is hard to completely exclude the possibility (or comes at the price of lesser flexibility). Wrong or unplanned finds carry big risks: the libraries could be of an unsupported version, wrong architecture, or missing the right header files. If you overlook a wrong find, and the build succeeds, you will likely get an error message at SC start-up. This is actually a good thing, because it allows to identify the actual problem. Far worse are generic error messages or mysterious crashes somewhere along the way because of a misfit.</p>
<p>The two most likely types of wrong finds occur either at the very beginning of the build, when CMake find-modules try to identify the libraries required for the build on your system, or at the very end (during "install"), when a CMake utility (bundle utilities) tries to find the libraries required to allow your build to work outside of the build environment (<em>standalone</em> in the meaning of <em>build environment independent</em> or <em>autonomous</em>).</p>
<p>There are two relatively easy ways to identify wrong finds at the beginning:</p>
<ul>
<li>use <code>cmake-gui</code> and look up the paths to all libraries in the list of build options presented in the central pane (if you are in doubt about the significance of envirnment settings when using CMake-Gui, please refer to the walkthrough 'Avoiding the command line: From CMake-Gui to Visual Studio'. The aspects relating to environment settings are relevant for other use cases as well)</li>
<li>study the file CMakeCache.txt in the root build folder. The quickest way to find the relevant entries is by searching for the library names (readline, sndfile, fftw and Qt5). Look for paths pointing to headers (include_dir), (import-) libraries, dll's and dll-directories.</li>
</ul>
<p>You can change build settings both in CMake-Gui and by editing CMakeCache.txt. CMakeCache.txt - the cmake configuration "cache" - also contains hints as to the function of the variables. You can directly edit this file, and new values will be used on reconfiguration of the build. This is equivalent to passing in variable assignments with the flag <code>-D</code> on the command line. These values will be stored in CMakeCache.txt and replace values assigned by CMake's search routines. It must be said though, that you are likely to be better of, if you identify the cause of the wrong find and fix it, rather than manually edit a configuration generated automatically.</p>
<p><em>Note</em>: if you reconfigure the build by running <code>cmake</code> after system changes (like deleting unwanted libraries or changing the path order), CMake will usually <em>not</em> overwrite values that have already been stored in the cache file. The cache serves to store values expected to be readable globally during the build, <em>and</em> values that have been passed into the configuration via the flag <code>-D</code>. During the build cache values are prioritized over values any cmake routine might produce. This priority order helps to protect manual edits of the build configuration, which can be done with <code>-D</code>, in CMake-Gui or by editing CMakeCache.txt. So keep in mind that implementing a different logic to create a value for a cmake variable (or e.g. moving a library to a place where it will be found by cmake) will not necessarily become effective in the next configure run. If the cache already contains a value assigned to that variable it will continue to use that value. A safe fix for this kind of problems is to delete the entire cache file, but it is usually sufficient to delete the variable(s) that should be reassigned values.</p>
<p>If you get wrong finds because of a conflicting system configuration (Qt4, different toolchains, individual libraries in high priority system locations (e.g. Windows or Windows) or in early PATH positions. Sometimes adding the parent folder of the intended library to the front of the environment path can help. If nothing works, temporarily renaming the offending libraries can take them out of the game. In principle the build system tries to anticipate these problems and prevent them. So if you bump into a new case, please report this on one of the SC mailing lists, or add an issue in SC's issue-tracker on Github.</p>
<p>The second candidate for wrong finds is the fixup_bundle utility at the very end of the install process. Remember, for developing SC the "install" step (building the target "install") is not required, SC can be run in the respective target folders - using and depending on the build environment settings. The development IDEs should be able to find the correct executable if you hit "run target". But if you want to start SC from the file explorer, or use a copy on another computer, you will need to "install" and then run from/copy the generated installation folder.</p>
<p>On Windows the bundle utility just reads out the dynamic libraries required to run an executable, tries to find them in the system, and copies them to the folder in which the executable resides. This is the safest way to guarantee that SC can be used independently of the build environment, because Windows executables always look for libraries in their own working directory <em>first</em>. Fixup_bundle just identifies libraries by their names (version and architecture are not verified). When it tries to find the libraries in the system, the environment PATH is taken into consideration with relatively high priority. Therefore it is theoretically possible that fixup_bundle finds different libraries from the ones used at build time. As a result your build will work, but the install won't. Even worse: the error messages produced in this case are far less specific than the ones produced if a library is simply missing.</p>
<p>Fortunately it is not too difficult to identify wrong finds of fixup_bundle, because it produces output that tells exactly, which libraries were copied to the executable folder. Further more it is the last install step, you just need to scroll up the cmake build output. So if you get obscure Windows system messages at SC start up, try to scroll up the install output, and go over the last segment, starting with <code>fixup_qt5_executable</code> and/or <code>fixup_bundle</code>. If you lost the output, just repeat <code>cmake --build . --target install</code>. Going over that list you might be able to spot cases where required libraries were copied from unintended places. A quick workaround to get SC running in such cases is to replace the wrong library by the correct one. A better workaround is to adjust your build environment, so that you don't have to repeat the replacement after each install. Adding the overlooked library's parent folder to the head of the environment PATH should usually do the job. Again, the build system was constructed to anticipate such errors and prevent them. All directories containing libraries are passed to fixup_bundle and should be treated with higher priority than the environment path. So if you bump into a case, please report it to the SC community. Or even better: create a pull request on Github that enhances the build system.</p>
<p>Of course there could also be bugs in the SC source. A source for the current build status of SC is the travis-ci status page:</p>
<p><a href="https://travis-ci.org/supercollider/supercollider">https://travis-ci.org/supercollider/supercollider</a></p>
<p>Unfortunately though there is no Continuous Integration system in place for Windows yet. Therefore you are strongly encouraged to report Windows build issues in one of the mailing lists, or the SC issue tracker on Github. Reporting Windows build issues is currently the only way to detect errors for SCWin resulting from progress in mainstream SC development.</p>
<h2>Walkthroughs </h2>
<h3>The trial-error approach: building sc3-plugins and passing build settings to <code>cmake</code></h3>
<p>sc3-plugins is a popular collection of binary extension to SC, providing many additional UGens. They are hosted in the SuperCollider repository on Github: </p>
<pre class="fragment">git clone --recursive https://github.com/supercollider/sc3-plugins.git
</pre><p>Like the core SuperCollider repo, this source collection contains sub-modules that may need to be re-synchronized when traversing the source history. The command is: </p>
<pre class="fragment">submodule update
</pre><p>Initialization and population of the submodules was automatically done because auf the flag <code>--recursive</code> at the initial clone. If at any point this is required again (message "submodule missing"), the command is: </p>
<pre class="fragment">submodule init
</pre><p>Git will usually tell, when a resynchronization is required. If cmake reports missing files during the build, it might be related to un-initialized and/or un-populated submodules.</p>
<p>This walkthrough expects that you have a working SC build environment in place. sc3-plugins do not have additional dependencies, so you are set. Furthermore Qt is not required, which makes things a bit easier. On the other hand the CMake find-modules provided with sc3-plugins often fail, so that more manual adjustment is likely to be required.</p>
<p>In order to find out which CMake variables need values, we can do a trial run. For this to be meaningful we need to</p>
<ul>
<li>add the toolchain binary path to the environment path before running <code>cmake</code></li>
<li>specify the generator (element after flag <code>-G</code>)</li>
<li><p class="startli">point <code>cmake</code> to the source (last element in <code>cmake</code> command, cannot be omitted on subsequent runs). For MinGW do: </p>
<pre class="fragment">$&gt; SET PATH=C:\Qt\Tools\mingw482_32\bin;%PATH%
$&gt; mkdir sc3-plugins-build
$&gt; cd sc3-plugins-build
$&gt; cmake -G "MinGW Makefiles" -D CMAKE_BUILD_TYPE=Release ..\sc3-plugins
</pre><p class="startli">For VS Studio the toolchain need not be added to the path. You just need to specify the generator like so:</p>
<p class="startli">$&gt; cmake -G "Visual Studio 12 2013 Win64" ..-plugins</p>
</li>
</ul>
<p>CMake will likely return two or three errors: </p>
<pre class="fragment">FFTW3F_INCLUDE_DIR=...NOT_FOUND
FFTW3F_LIBRARY=...NOT_FOUND
SC_PATH=...NOT_FOUND
</pre><p>We know the SC path, and we also know the location of the 32-bit fftw library, which was used in the SC build. The expected library is likely dynamic, so we need to specify the .dll (no .dll.a available) file in the <code>bin</code> folder. Let's do another trial run with the added information: </p>
<pre class="fragment">$&gt; cmake -DFFTW3F_INCLUDE_DIR=..\x86\fftw -DFFTW3F_LIBRARY=..\x86\fftw\libfftw3f-3.dll -DSC_PATH=..\supercollider ..\sc3-plugins
</pre><p><em>Note</em>: there should not be any spaces after the <code>=</code> in variable assignments. While cmake is lenient with spaces after the flags (<code>-D</code>, <code>-G</code> etc.), a space after <code>=</code> is interpreted as a delimiter indicating the next element in the command. The variable gets assigned "nothing" and the following path may be wrongly interpreted as the path to the source. Another rule concerning spaces: if a <em>path</em> contains a space, it must be enclosed in quotation marks.</p>
<p>We shouldn't get any more errors, time to build!</p>
<p>Note that CMake stores the variables you set manually in a file called <code>CMakeCache.txt</code>, located in the build folder. It is not required to re-enter values that have been stored there (except you want to overwrite them with different values, of course). It is possible to change configuration values by editing this file. If you get stuck and decide to configure the build from scratch, you can delete that file and restart. This way you can keep the files that have already been built, while making sure that all configuration values you add are generated from anew. This can save a lot of compile time. At times though, you might experience that it is necessary to remove everything in the build folder.</p>
<p>There could also be variables that define build options without producing errors if no value is set. They can be listed by adding the flag <code>-L</code> to the configure run: </p>
<pre class="fragment">$&gt; cmake .. -L
</pre><p>This will show us amongst other things, that an option to build plugin versions for the alternative audio server <code>supernova</code> is available (not availale in VS builds). To add them to the build, just run: </p>
<pre class="fragment">$&gt; cmake -DSUPERNOVA=ON ..
</pre><p>The old settings will stay in place.</p>
<p>Ready to build: </p>
<pre class="fragment">$&gt; cmake --build . --target install
</pre><p>This works for both MinGW and VS. In the VS build you may want to specify the build type: </p>
<pre class="fragment">$&gt; cmake --build . --target install --config Release
</pre><p>Unfortunately on Windows we will get an error at the end of this build, because CMake wants to install the files to the Windows default install location, which is the folder "Program Files (x86)". This path requires elevated access rights and contains an empty space, the install fails. Further more, installing the plugins to the application folder doesn't make much sense, we want to have them around in a folder we can easily add to the folders scanned by <code>scsynth</code> and/or <code>supernova</code>.</p>
<p>In order to correct this error, we need to rerun the configuration and set an install folder in user space that does not contain a space. The variable for this purpose is CMAKE_INSTALL_PREFIX: </p>
<pre class="fragment">$&gt; cmake -DCMAKE_INSTALL_PREFIX=./Install ..

$&gt; cmake --build . --target install
</pre><p>This will copy all files to the subfolder <code>Install</code> in the build folder. The second build should proceed very quickly as CMake only builds changed components from scratch.</p>
<p>If you execute a build command, CMake compares the time stamps of source files with the time stamp of the last build, to determine if anything has changed. So if you don't need to verify that a reconfiguration was successful, you can just execute the build command without running CMake manually. CMake will be triggered automatically if required (according to what CMake believes is correct in a certain situation - which isn't necessarily correct ;) ).</p>
<p>On the command line two things are important time savers: when entering paths, tab completion works, which helps avoiding typos. Also the history function (arrow up) is very useful. CMake will not always detect typos in path assignments. If a wrong path is entered, this will only become apparent in the build ("header not found" etc.). CMake-Gui makes setting variables a lot more comfortable, but you have to make sure to set the system- or shell- environment values mentioned above before running <code>cmake-gui</code>. Important to understand here is that the environment variables have to be set in a place, where CMake-Gui <em>inherits</em> them. If you set them at the command line (in a "shell") you need to start CMake-Gui from that shell (by entering <code>cmake-gui</code>). If you start CMake-Gui from the Windows Start Menu, the environment variables must be set on system level. The same is obviously true for a development IDE.</p>
<h3>Avoiding the command line: from CMake-Gui to Visual Studio (environment and GUI-applications)</h3>
<p>If you think you prefer to avoid the command line, there is the tempting option of running CMake-Gui from the Windows Start Menu. While this is possible, there is an important caveat: when run from the Windows Start Menu, CMake-Gui runs in the environment defined by the overall system set during login. This means you cannot set the path on the command line (in a <em>shell</em>), but have to make the path adjustments on system level (using Control Panel/System/Advanced System Settings/Environment Variables). Setting the PATH on system level brings along some risks that need to be managed carefully, most importantly: adding Qt5 (or a toolchain) at the head of the system PATH can cause other applications that may depend on similar path settings, to malfunction. This can be easily corrected by removing the offending entry when done with SC development (and avoiding the conflicting application in the meantime), but this might not always be possible. So we need to keep in mind: While working on a SC build with changed <em>system environment</em> settings, other applications might get into trouble. Most common cases are applications that depend on some implicit Qt install added to the PATH, or MinGW applications that require MinGW runtime libraries that don't fit the ones used in our build. It is not best practice to rely on the path to find libraries, but it is quite common, especially among free applications stemming from the unix world, where people are used to a homogenous system, in which all applications use the same shared libraries. To avoid potential trouble, you might want to make your environment adjustments on the command-line <em>and</em> start <code>cmake-gui</code> form that same shell.</p>
<p>Once CMake-Gui is running it will need to know (just like on the command line):</p>
<ol type="1">
<li>the Qt location<ul>
<li><p class="startli">While Qt can be added via the PATH as well, it is safer to define an environment variable "CMAKE_PREFIX_PATH", that contains the path to the parent folder of the "Qt-system" we are using. The Qt-architecture must fit the build system, in this case Microsoft Visual Studio 2013, 64-bit. In a standard install, the path is likely to be: </p>
<pre class="fragment">C:\Qt\5.5\msvc2013_64
</pre><p class="startli">You can modify the Windows environment variables by hitting Win-key-x, choosing <code>System</code> -&gt; <code>Advanced System Settings</code> -&gt; <code>Environment Variables</code>. Apply the <code>SET CMAKE_PREFIX_PATH=C:\Qt\5.5\msvc2013_64</code> logic to this dialog. Note that there is no <code>bin</code> in the CMAKE_PREFIX_PATH, this is <em>not</em> a binaries search path, but an anchor path for CMake to work out all relevant Qt locations. After the addition it might be necessary to re-login. You should experiment as to whether this is necessary on your system, with your Windows version. Applications behave different as to whether they instantly react to system environment changes or stick to the environment set up at login or system boot. So far it looks as if cmake-gui, Visual Studio and also the file- explorer are among the applications that sense environment changes instantly, but your experience may differ.</p>
<p class="startli">Only start CMake-Gui <em>after</em> this adjustment has been made.</p>
</li>
</ul>
</li>
<li>the path to the build folder and the SC source<ul>
<li>they can be comfortably selected in the two text boxes at the top of the window.</li>
</ul>
</li>
<li>the generator to use<ul>
<li>The generator can be selected in a dialog that opens, when you hit the 'Configure' button. Make sure to pick the 64-bit toolchain.</li>
</ul>
</li>
<li>the path to the toolchain<ul>
<li>In the case of Visual Studio CMake can reliably deduct the toolchain-path from an environment variable set by Visual Studio. This could only be an issue if you have several versions of Visual Studio installed on your system.</li>
</ul>
</li>
</ol>
<p>After the required assignments have been made, CMake-Gui will attempt to configure the build. If this attempt returns errors, you will have provide additional values. After the configuration CMake-Gui will present you with a long list of cmake variables alongside with the values assigned to them as stored in the cache. In the box at the bottom you can scroll through the output CMake produced during configuration and analyse it. At this stage it is good to scroll through the central pane and check for the paths related to the "smaller" libraries (libsndfile, fftw (and readline, you want to work on that)) and the Qt5 related paths. Do they fit the locations we expect? If not, you may try to correct it in the window presented. On the other hand, errors in this stage are more likely to be caused by conflicts with your system settings, typos in paths or the like. In that case it is better to fix the error at its root, as such mistakes are likely to cause build errors later on. Common causes are conflicting Qt and MinGW installs, or alternative versions of the smaller dependencies that were detected by CMake. In that case you will have to work out, how to correct things while both keeping your overall system functional, and allowing for a successful SC build.</p>
<p>If everything looks okay, you need to hit "generate" to create the files used to build by VS. CMake-Gui introduces a distinction between 'configure' and 'generate'. If we use trial-error mode, this is quite useful, as generating VS project files can take quite some time.</p>
<p><em>Note</em>: not every "NOT-FOUND" entry necessarily indicates an error. At least in theory only NOT-FOUNDs <em>creating a CMake error</em> should be problem.</p>
<p><em>Note</em>: If you come back after changing your library locations, the safest thing is to delete the build settings cache (<code>CMakeCach.txt</code> in the build folder) and rerun the configuration from scratch. Otherwise old settings might stick. You can delete the file yourself or use the more radical "delete cache" in CMake-gui's file menu, which will delete the entire build folder. You may also want to restart CMake-Gui, as it keeps manually entered settings for a subsequent run regardless of whether the cache has been deleted or not. That can be helpful at times, and confusing in other situations.</p>
<p><em>Note</em>: resist the temptation to enable all options that seem promising. Some of them don't work in the Windows build. For example the supernova server can't be built with VS yet. Usually SuperCollider's default values are a considered choice that should only be changed for a good reason (see the walkthrough for "More CMake" for some options that do work).</p>
<p>CMake will generate a solution file in the build folder. Use it to start VS, and you are ready to develop and build in this feature rich IDE. If you started CMake-Gui from a command line/shell, should start Visual Studio from that shell as well, to run Visual Studio in the same environment as CMake-Gui: </p>
<pre class="fragment">$&gt; start SuperCollider.sln
</pre><p>If you set the environment on Windows system level, you can start Visual Studio in your preferred way. Once the "solution file" is open in Visual Studio, you are ready to build. You can either chose "Build-&gt;Build solution" or right-click the <em>target</em> "ALL_BUILD", or "Supercollider" and select "BUILD". Once the build is completed you should be able to run any of the targets that contain executables: </p>
<pre class="fragment">SuperCollider
sclang
scsynth
</pre><p>The targets can be selected most comfortably in the "Solution Explorer". Right-click the wished target and select "Debug". The application should come up after a while. If you find that VS has problems finding the target-executable, you will have to adjust some configuration settings. Right-click the target and chose 'Configure'. You will find an option to select the target executable path. Note that these are VS user settings not passed on to CMake. While in theory it would be possible to have CMake generate VS user settings, it is hard to keep CMake generated VS user-settings in sync with changes made from within Visual Studio. Therefore you should not expect CMake to know anything about the changes you made within Visual Studio.</p>
<p>In order to boot the server from scide or sclang, it is necessary to set the working directory for the respective target. This can be done in the "Debug" pane of the target properties dialog.</p>
<p><em>Important Note</em>: provided the build environment is set up properly (the main setting is the requirement to have the Qt5/bin folder in the PATH of the current environment), the various SC components can be run directly in the target folders. If you want to run SC outside of the build environment, or copy the build to a different computer, you need to build the target "install". This step will create a autonomous install of SuperCollider, without any outside dependencies except files guaranteed to be available on every Windows system. Building the install target takes some time, as all SC files are copied to a separate install folder, and a CMake utility, "bundle utilities", tries to detect all libraries that the SC executables require to run. The bundle utility copies those to the install folder, as that is the only way to guarantee that they will be available wherever SC is run. Copying the libraries to the SC install folder also guarantees that exactly these libraries are used by SC, and not some other version or architecture that may be "findable" via the current system/environment search PATH.</p>
<h3>Using Qt Creator</h3>
<p>QtC is likely the IDE with the best CMake-, as well as Qt integration, therefore it fits our requirements very well. The base steps, namely pointing to the toolchain and Qt are handled as part of defining "kits", and controlled via comfortable selection dialogs. You can open a CMake project directly, and run <code>cmake</code> from within the IDE, quite similar to how you would work with CMake-Gui. QtC automatically creates environment variables adjusted to the kit used (i.e. Qt5 and the toolchain are found and added to the PATH as required), without interfering with the overall system. You can "run" the SC targets containing executables directly from within QtC. In order to start the server from the SC-IDE or sclang, you will have to set the "working directory" to the target folder in the Projects/Run pane.</p>
<p>QtC can handle a CMake project once it knows the location of the <code>CMakeLists.txt</code> file in the source root folder. It does not require a dedicated generator, but uses the "MinGW Makefiles" one automatically. It can configure the build using CMake in a similar way as CMake-Gui does. You can also do trial CMake runs, and add variable assignments in a text input box (preceded by <code>-D</code>). While not presenting the build options in a neat list, it allows you to edit the CMakeLists.txt files themselves in a meaningful context.</p>
<p>In a kit, among other things (debugger, source control system and more), you can select one (among potentially several) Qts on your system, and chose a toolchain to combine with. If your Qt is installed in a standard location, it is likely that QtC already created a kit at start-up that fits the needs. While QtC can be used to build with the MS toolchain, it is the more likely choice when building with MinGW. So before opening the SC project, we may need to create the right kit: Qt5.5.1-mingw492_32 combined with mingw482_32. This can be done in Tools -&gt; Options -&gt; Kits and should be self-explanatory.</p>
<p>Next step is to open the project (File -&gt; Open File or Project) by pointing to the root CMake script (CMakeLists.txt) in the top parent folder of the SC source. Then QtC will prompt you for a build folder and run <code>cmake</code>. This dialog is well adapted to the trial-error approach of aggregating the required variable assignments for the build (see "CMake-Gui to VS", or "Building sc3-plugins"). Once CMake returns no errors you should be ready to build.</p>
<p>For managing your build you will typically visit the "Project Pane". It offers two sub-panes where you can make choices relating to build definition and install/ deployment. It is the place to add predefined alternative kits with a dedicated build folder (for alternative builds), modify the environment in which the build is executed, or add more build steps or targets (e.g. install, installer). You can also chose individual targets to be built here. Each build step can be conveniently clicked on or off. You may also assign additional build steps to the second project pane "run", where install related steps are best placed. This is also the place to select the target that is started when SC is "Run" or "Debug"ged from the mode selector ribbon. Note though that the steps defined there are executed each time you hit "Run" or "Debug", so it is not always helpful to have these steps active during a development cycle.</p>
<p>In order to create a binary installer, you will want to add the (custom) target <code>installer</code>. It creates a binary containing all files required to run SC autonomously (NSIS required). But if you are not working on the installer itself, you will likely only want to activate that step at the end of a development cycle.</p>
<h3>More <code>cmake</code>: building supernova, qt-less, verbosity and more</h3>
<p>Learn more about the CMake options by running <code>cmake --help</code>. A good window into the SC build configuration is the file CMakeCache.txt in the build folder. The most comprehensive information is of course contained in the CMakeLists.txt files scattered over the project source tree, starting from the source root folder. A longer list of variables defined for the SC build is retrieved by adding the flags -L or -LA ('list advanced') to the command <code>cmake ..</code>.</p>
<p>The file CMakeCache.txt can be manually edited and is the best place to verify that variables have been assigned the values expected. Keep in mind that the <code>clean</code> step does not delete or change this file. This simplifies configuration, but may also cause trouble if wrong values are kept. To make sure CMake generated values are updated correctly, remove the respective variables from the file or delete the entire file. To make sure object files are recompiled, "build" the <code>target clean</code>. To avoid any contamination by an old build, delete the entire build folder. Of course each of these measures significantly extends the time needed to complete a build.</p>
<p>If you get mysterious build failures (i.e. no CMake error message that helps), sometimes increasing cmake output verbosity during the build gives you information that helps working out what went wrong: </p>
<pre class="fragment">cmake --build . -- VERBOSE=1
</pre><p>You can pass other make/mingw32-make/msbuild arguments after "--". To speed up your build "-j4" with MinGW ("-m4" with VS) might work: </p>
<pre class="fragment">cmake --build . -- -j4
</pre><p>Commonly used variables to modify the build configuration are:</p>
<ul>
<li><p class="startli">Location where SC gets "installed", which in this context means: where the SC files - including required external libraries - get copied to if you build the target "install". The default location is set to './Install'. If you maintain multiple builds you could either use different build trees or install to different folders. Change this for example like so: </p>
<pre class="fragment">-D CMAKE_INSTALL_PREFIX=./x86/AllPullRequests
</pre><p class="startli">This installs the files to a subfolder x86/AllPullRequests of the build- directory. Note that CMake uses forward slash as folder separator on all platforms. You may also specify an absolute path here. Building the install target is a precondition to creating a binary installer. Apart from copying all SC files to an install folder, it executes a command that pulls in all required libraries to run SC without depending on shared libraries other than the system libraries guaranteed to be available on every Windows system. The binary installer adds some comfort, enhances SC system integration and cleanup on uninstall, but it is not required to run SC autonomously.</p>
</li>
<li>Enable compiler optimizations for your local system (could cause a faster binary, but could also cause build problems. Don't use this if building for computers with different CPUs than your own) <pre class="fragment">-D NATIVE=ON                             # gcc/mingw only
</pre></li>
<li><p class="startli">Build the <em>supernova</em> server: </p>
<pre class="fragment">-D SUPERNOVA=ON
</pre><p class="startli"><em>Note</em>: When you build with supernova, an alternative server executable and a supernova version of each plugin is built. If you also use the 'sc3-plugins' package, make sure to compile them with supernova support too. At the time of this writing supernova could only be built with the MinGW toolchain.</p>
<p class="startli">Within SC you will be able to switch between scsynth and supernova by evaluating one of lines below and then booting the server as usual: </p>
<pre class="fragment">Server.supernova
Server.scsynth
</pre><p class="startli">Check SC help for <code>ParGroup</code> to see how to make use of multi-core hardware.</p>
<p class="startli"><em>Note</em>: If you experience problems getting the supernova plugins recognized (plugins related error at supernova boot), try placing them in a folder called "plugins" in the "userAppSupportDirectory\Extensions" folder. It may also be required to separate binary plugins and classes. The class files may reside anywhere in the Extensions folder (or in any "included" class folder), whereas the binary plugins should reside in a folder "plugins" (this mirrors the situation in the application directory)</p>
<p class="startli"><em>Note</em>: While there is no readily available 64-bit Qt version for the MinGW build, supernova does not depend on Qt. Therefore a qt-less build could be used to build a 64-bit version of SuperNova, and combine it with the 64-bit VS build of the IDE and sclang (using MinGW runtimes for supernova). The 64-bit build of supernova currently breaks, but might be more easy to fix than the VS build.</p>
</li>
<li><p class="startli">It is possible to build SuperCollider without the IDE, and even without Qt (and implicitly without the IDE). This is not controlled via build targets, but via CMake variables: </p>
<pre class="fragment">-DSC_IDE=OFF
</pre><p class="startli">This will not build the IDE, but keep Qt in sclang. With the more radical setting: </p>
<pre class="fragment">-DSC_QT=OFF
</pre><p class="startli">SC will not link to Qt at all, and implicitly build without the IDE. This build variation is used in low resources environments and graphic-less use scenarios of SC. In the Qt-less build some Qt/GUI related classes are removed from the SCClassLibrary to avoid primitive not found errors at sclang start-up. The removed classes can be found in the folder SCClassLibrary/scide_scqt. If you need to run code with elements considered deprecated in SC3.7, you can move the deprecated/3.7 folder back into place. You should remove the unsupported Document-class related entries to avoid (non-fatal) errors at sclang start-up.</p>
<p class="startli">You cannot use the Help browser in Qt-less SC. An option is, to render Help with sclang (<code>SCDoc.renderAll</code>) and run it in a browser. There is also the option to build, or pre-render the entire documentation during build time to a subfolder "RenderedHelp" in the build folder. This is enabled by setting "SC_DOC_RENDER" to on: </p>
<pre class="fragment">-DSC_DOC_RENDER=ON
</pre><p class="startli">You can also avoid <em>installing</em> the (unrendered) HelpSource: </p>
<pre class="fragment">-DINSTALL_HELP=OFF
</pre></li>
<li><p class="startli">Server-only: Currently there is no straightforward way to build server-only. Even if you mark only the server target (and the plugins), sclang is pulled in as well. So a bit of patience is required. You can turn off Qt (<code>-DSC_QT=OFF</code>) and skip Readline, to save on the dependencies. To make it easier to assemble a server bundle, the custom target "install_server_only" is provided. It can be used in place of the comprehensive "install". The custom target will copy scsynth's target folder and run fixup_bundle on scsynth to pull in required libraries.</p>
<p class="startli"><em>Note VS</em>: As this is not a proper install, the MS runtime libraries (msvcp120.dll and msvcr120.dll) are not copied. If required, get them from a full SC install, or from the VS/VC/redist folder.</p>
</li>
<li>SClang-no-Qt: the modifications to the SCClassLibrary are only done automatically in the build to the target folder. If you run the target "install", you get the unmodified class library. The changes are just:<ul>
<li>move or delete Common/GUI and JITLib/GUI</li>
</ul>
</li>
</ul>
<p>More options can be explored by studying CMakeCache.txt in the build folder, or file CMakeLists.txt in the root folder of the SC source.</p>
<h3>Recalling environment- and build settings on the command line</h3>
<p>While using the command line for the build provides a safe, low system impact way of doing your thing, it does require a lot of typing, especially if you need to do this each time you re-enter a build shell (i.e. open a command line window ;) )</p>
<p>The solution is: store the commands required to make the environment settings in a batch-file (.bat or .cmd) and never type those settings again. Simple Windows batch-files are basically series of commands in their own line each. You can run a batch-file automatically upon opening a command line window, by passing the path to the batch file to the command that opens the command window (after the flag /k). This can further be automated by storing the start-cmd in a link opening a command line window. Just copy the link called "Command prompt" and access the properties for that link. The "Target" input-box can take the command that opens the command line window <em>and</em> runs your batch file, e.g.: </p>
<pre class="fragment">%COMSPEC% /A /Q /K %USERPROFILE%\qtenvQt5.5mingw492_32.bat
</pre><p>If the batch file contains these lines: </p>
<pre class="fragment">echo off
echo Setting up environment for Qt usage...
echo Qt 5.5 mingw492_32 paired with MinGW 4.8.2
set PATH=C:\Qt\5.5\mingw492_32\bin;C:\Qt\Tools\mingw482_32\bin;%PATH%
set CMAKE_PREFIX_PATH=C:\Qt\5.5\mingw492_32
</pre><p>You are set to start the environment for the MinGW build system with a single click. But there is more, e.g. DOSKEY, the Windows alternative to Unix' <code>alias</code>, e.g.: </p>
<pre class="fragment">DOSKEY cmDb=cmake -G "MinGW Makefiles" -D CMAKE_BUILD_TYPE=Debug %USERPROFILE%\Projects\sc\supercollider
DOSKEY cmRl=cmake -G "MinGW Makefiles" -D CMAKE_BUILD_TYPE=Release %USERPROFILE%\Projects\sc\supercollider
DOSKEY mk=cmake --build .
DOSKEY mki=cmake --build . --target install
DOSKEY cds=cd %USERPROFILE%\Projects\sc\supercollider
DOSKEY cdbdb=cd %USERPROFILE%\Projects\sc\supercollider\build_MW_Db
DOSKEY cdbrl=cd %USERPROFILE%\Projects\sc\supercollider\build_MW_Rl
DOSKEY cdd=cd %USERPROFILE%\Projects\sc\deployment\mingw492_32
</pre><p>These lines create a VS environment: </p>
<pre class="fragment">echo off
echo Setting up environment for Qt usage...
set PATH=C:\Qt\5.5\msvc2013_64\bin;%PATH%
set CMAKE_PREFIX_PATH=C:\Qt\5.5\msvc2013_64
echo Running vcvarsall.bat to complete environment setup!
call "C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\vcvarsall.bat"
echo Done!
cd /D %USERPROFILE%\Projects\sc\supercollider
DOSKEY cm=cmake -G "Visual Studio 12 2013 Win64" %USERPROFILE%\Projects\sc\supercollider
DOSKEY mkDb=cmake --build . --config Debug
DOSKEY mkRl=cmake --build . --config Release
DOSKEY mkDbI=cmake --build . --config Debug --target Install
DOSKEY mkRlI=cmake --build . --config Release --target Install
DOSKEY cds=cd %USERPROFILE%\Projects\sc\supercollider
DOSKEY cdb=cd %USERPROFILE%\Projects\sc\supercollider\build_VS
DOSKEY cdd=cd %USERPROFILE%\Projects\sc\deployment\msvc2013_64
</pre><p>Another option are batch-files that construct CMake arguments and execute the build. If for some reason you need to enter many of those and/or can't keep the build folder with the cache file, this can come in handy. Here is a example that allows to edit all paths to dependencies. They go into a single environment variable (<code>CMAKE_PREFIX_PATH</code>) that CMake will read. The lines here contain random assignments to demonstrate some possibilities. Note that the batch files above use Windows path syntax, while the one below uses forward slash for CMake: </p>
<pre class="fragment">set CMAKE_GENERATOR="Visual Studio 12 2013 Win64"
set QT_HOME=C:/Qt/5.5
set QT_FLAVOUR=msvc2013_64
set QT_PREFIX_PATH=%QT_HOME%/%QT_FLAVOUR%
set SNDFILE_PREFIX_PATH="C:/Program Files/nerd/libsndfile"
set FFTW_PREFIX_PATH=%USERPROFILE%/fftw
set READLINE_PREFIX_PATH=D:/scdeps/x64/readline
set CMAKE_PREFIX_PATH=%QT_PREFIX_PATH%;%SNDFILE_PREFIX_PATH%;%FFTW_PREFIX_PATH%;%READLINE_PREFIX_PATH%
cmake --build .
start Supercollider.sln
</pre><p>Another way of storing CMake command line arguments is creating a "toolchain" file. This is the CMake suggested method. Please look up the CMake documentation if you require an advanced configuration, and are interested in this approach.</p>
<h2>Description of the SC 3.8 release build </h2>
<p>All dependencies not contained in the SC source (external_libraries) were downloaded from the original providers (see links at the end). For both VS and QT the free community editions were used.</p>
<p>SCWin64 3.8 was built with Visual Studio 12/2013</p>
<ul>
<li>Qt5.5.1 (flavour msvc2013_64)</li>
<li>libsndfile 1.0.27</li>
<li>FFTW 3.3.5</li>
</ul>
<p>SCWin32 3.8 was built using Qt Creator, combining MinGW 4.8.2 and Qt 5.5.1 mingw492_32 into a kit. The MinGW distribution provided by Qt was used.</p>
<ul>
<li>linsndfile 1.0.27</li>
<li>FFTW 3.3.5</li>
<li>Readline 5.0.1 (as provided by gnuwin32)</li>
</ul>
<p>For both builds all other external libraries (including portaudio) were compiled as part of the SC build, using the sources embedded in the SC source tree (in the folder external libraries) and the settings defined there.</p>
<p>The portaudio build was extended for ASIO support by adding the ASIO-SDK:</p>
<ul>
<li>ASIO SDK 2.3</li>
</ul>
<p>For DSound support different DirectX versions had to be used in the VS and MinGW build. For VS:</p>
<ul>
<li>DirectX v9 (June 2010)</li>
</ul>
<p>The MinGW build uses the libraries coming with MinGW.</p>
<p>The tools used were Git for Windows v2.10.2.windows.1, cmake v3.52, and NSIS v3.0b1 to create the binary installer.</p>
<h1>Known problems </h1>
<ul>
<li>READLINE/Command line-mode does not work properly. You have to wait a short while with the key pressed to get it to register - if you wait for too long, the key will repeat. It's kind of possible to get used to it for a short while. Second problem: sclang will crash if you use ctrl-d. Another problem shared with the IDE: You need to stop the server process manually to avoid scsynth-zombies. Readline is initialized in lang/LangSource/SC_TerminalClient.cpp (readlineInit()). This problem can only be studied in the MinGW build for now, as the VS build (even 32-bit) cannot link to the readline lib yet (and you can only use v. 5.0.1 which isn't available as 64-bit binary).</li>
<li>using shell commands from SC only works in a quite limited way (and always did). .unixCmd expects a unix shell, only for essential requirements workarounds are in place on Windows.</li>
<li>serial port communication does not work on Windows</li>
<li>your username should not contain spaces or non-ASCII characters</li>
</ul>
<p>A build issue that does not seem to create a problem:</p>
<ul>
<li>during the MinGW build, when statically linking portaudio, we currently get several dozen non-fatal errors (this is not due to the portaudio version, it has been observed with several pa-builds. Similar errors are reported in unrelated contexts and have to do with boost). These errors seem to have no consequence: <pre class="fragment">CMakeFiles\SuperCollider.dir\objects.a(find_replace_tool.cpp.obj):-1: error: duplicate section `.data$_ZGVZN5ScIDE4Main8instanceEvE9singleton[__ZGVZN5ScIDE4Main8instanceEvE9singleton]' has different size
...
</pre></li>
</ul>
<h1>Outro </h1>
<p>Thanks to James McCartney, for making this great piece of audio software publicly and freely available. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
